# calculadora_con_interfaz_grafica_python_oracle
Calculadora con interfaz gráfica (Tkinter) y persistencia en Oracle .

Este repositorio/ejemplo contiene una aplicación completa en Python que implementa una calculadora con interfaz gráfica usando **Tkinter** y que guarda el historial de calculos en una base de datos **Oracle** mediante la libreria `oracledb` .

> ⚠️ **Nota de seguridad:**  
> No incluyo credenciales reales. Rellena `config.py` con los datos de tu BD o usa variables de entorno/.env en produccion .  
> Evita dejar contraseñas en texto plano.

---

## 1) Script SQL (crear tabla)

```sql
-- Crear tabla para historial de cálculos
CREATE TABLE CALCULATIONS (
  ID          NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  EXPRESSION  VARCHAR2(4000),
  RESULT      VARCHAR2(4000),
  CREATED_AT  TIMESTAMP DEFAULT SYSTIMESTAMP
);

-- opcional : conceder permisos al usuario si hace falta
-- GRANT INSERT, SELECT ON CALCULATIONS TO tu_usuario;

2) config.py (plantilla)
Guarda este archivo en el mismo directorio que calculator.py y reemplaza los valores por los de tu entorno .

# config.py
# Rellena estos valores con los de tu entorno oracle :

DB_USER = "mi_usuario"
DB_PASSWORD = "mi_contraseña"
DB_DSN = "host:puerto/servicio"  # ejemplo: "localhost:1521/XEPDB1"

# Alternativa usando variables de entorno en produccion :
# import os
# DB_USER = os.getenv("DB_USER")
# DB_PASSWORD = os.getenv("DB_PASSWORD")
# DB_DSN = os.getenv("DB_DSN")

3) calculator.py (fragmento destacado) .
copia este archivo como calculator.py. aqui se muestra un fragmento relevante para la interaccion con la interfaz y el historial :

# History listbox
lbl = ttk.Label(self, text="Historial (Oracle):")
lbl.grid(row=0, column=4, padx=(10,0), pady=(10,0), sticky="nw")

self.history_lb = tk.Listbox(self, height=25, width=45)
self.history_lb.grid(row=1, column=4, rowspan=6, padx=(10,10), pady=10, sticky="nsew")
self.history_lb.bind("<Double-Button-1>", self._on_history_double_click)

def _on_button_click(self, label):
    if label == "C":
        self.display_var.set("")
    elif label == "=":
        expr = self.display_var.get().strip()
        if not expr:
            return
        try:
            result = safe_eval(expr)
            # Formatear resultado (evitar notación científica si no es necesario)
            if isinstance(result, float) and result.is_integer():
                result_str = str(int(result))
            else:
                result_str = str(result)
            # Mostrar
            self.display_var.set(result_str)
            # Guardar en BD
            try:
                insert_calculation(expr, result_str)
            except Exception as db_e:
                messagebox.showwarning("BD", f"Error guardando en BD: {db_e}")
            # Actualizar historial
            self._load_history()
        except Exception as e:
            messagebox.showerror("Error", f"No se pudo evaluar la expresión:\n{e}")
    else:
        # añadir texto al display
        cur = self.display_var.get()
        new = cur + label
        self.display_var.set(new)

def _load_history(self):
    try:
        rows = fetch_recent_calculations(limit=30)
        self.history_lb.delete(0, tk.END)
        for r in rows:
            _id, expr, result, created = r
            created_str = created.strftime("%Y-%m-%d %H:%M:%S") if isinstance(created, datetime) else str(created)
            line = f"[{_id}] {created_str} — {expr} = {result}"
            self.history_lb.insert(tk.END, line)
    except Exception as e:
        # no bloquear la UI si no hay BD disponible; mostrar mensaje y seguir
        self.history_lb.delete(0, tk.END)
        self.history_lb.insert(tk.END, f"Error cargando historial: {e}")

def _on_history_double_click(self, event):
    sel = self.history_lb.curselection()
    if not sel:
        return
    text = self.history_lb.get(sel[0])
    # extraer expresión (buscamos "— expr = result")
    try:
        # formato: "[id] fecha — expr = result"
        parts = text.split("—", 1)
        if len(parts) >= 2:
            right = parts[1].strip()
            expr_part = right.rsplit("=", 1)[0].strip()
            self.display_var.set(expr_part)
    except Exception:
        pass

if __name__ == "__main__":
    app = CalculatorApp()
    app.mainloop()

4) Pasos para ejecutar
Crea y ejecuta el script SQL en tu Oracle para crear la tabla CALCULATIONS .

Crea un entorno virtual (opcional pero recomendado):
bash
python -m venv venv
# Windows
venv\Scripts\activate
# Linux / macOS
source venv/bin/activate

Instala dependencias:
bash
pip install oracledb

si necesitas el cliente Oracle (thick mode) consulta la documentación de oracledb.
En la mayoría de instalaciones con Oracle XE / servidor remoto y usando thin mode no necesitas instalar cliente adicional.

Rellena config.py con tus credenciales y DSN.

Ejecuta la aplicación:
bash
python calculator.py

5) Notas y seguridad
safe_eval usa ast para evitar ejecución arbitraria de código; cubre operaciones aritméticas básicas.
No permite funciones externas (como sin, cos) ni nombres.
En producción, no almacenes credenciales en config.py en texto plano: usa variables de entorno o un gestor seguro.
Si tu Oracle requiere el Oracle Client (thick mode), puede ser necesario llamar a:

python
oracledb.init_oracle_client(lib_dir="...")
antes de conectar. Revisa la documentación oficial de oracledb .

Si deseas permitir funciones matemáticas (sin, sqrt, etc.), se puede añadir un mapeo controlado de funciones de math con seguridad .
