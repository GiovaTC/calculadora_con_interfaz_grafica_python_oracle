# calculadora_con_interfaz_grafica_python_oracle
calculadora con interfaz gráfica (Tkinter) y persistencia en Oracle :

este repositorio/ejemplo contiene una aplicación completa en Python que implementa una calculadora con interfaz gráfica usando 
Tkinter y que guarda el historial de cálculos en una base de datos Oracle mediante la librería oracledb.

Nota de seguridad: No incluyo credenciales reales. Rellena config.py con los datos de tu BD o usa variables de entorno/.env en producción. 
Evita dejar contraseñas en texto plano.

1) Script SQL (crear tabla) .
-- Crear tabla para historial de cálculos
CREATE TABLE CALCULATIONS (
  ID          NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  EXPRESSION  VARCHAR2(4000),
  RESULT      VARCHAR2(4000),
  CREATED_AT  TIMESTAMP DEFAULT SYSTIMESTAMP
);

-- opcional : conceder permisos al usuario si hace falta .
-- GRANT INSERT, SELECT ON CALCULATIONS TO tu_usuario;
2) config.py (plantilla)
guarda este archivo en el mismo directorio que calculator.py y reemplaza los valores por los de tu entorno .

# config.py
# rellena estos valores con los de tu entorno Oracle :
DB_USER = "mi_usuario"
DB_PASSWORD = "mi_contraseña"
DB_DSN = "host:puerto/servicio"  # ejemplo: "localhost:1521/XEPDB1"

# alternativa usando variables de entorno en produccion :
# import os
# DB_USER = os.getenv("DB_USER")
# DB_PASSWORD = os.getenv("DB_PASSWORD")
# DB_DSN = os.getenv("DB_DSN")

3) calculator.py ( aplicación completa ) .

copia este archivo como calculator.py .

calculator.py
# History listbox
lbl = ttk.Label(self, text="Historial (Oracle):")
lbl.grid(row=0, column=4, padx=(10,0), pady=(10,0), sticky="nw")


self.history_lb = tk.Listbox(self, height=25, width=45)
self.history_lb.grid(row=1, column=4, rowspan=6, padx=(10,10), pady=10, sticky="nsew")
self.history_lb.bind("<Double-Button-1>", self._on_history_double_click)


def _on_button_click(self, label):
if label == "C":
self.display_var.set("")
elif label == "=":
expr = self.display_var.get().strip()
if not expr:
return
try:
result = safe_eval(expr)
# Formatear resultado (evitar notación científica si no es necesario)
if isinstance(result, float) and result.is_integer():
result_str = str(int(result))
else:
result_str = str(result)
# Mostrar
self.display_var.set(result_str)
# Guardar en BD
try:
insert_calculation(expr, result_str)
except Exception as db_e:
messagebox.showwarning("BD", f"Error guardando en BD: {db_e}")
# Actualizar historial
self._load_history()
except Exception as e:
messagebox.showerror("Error", f"No se pudo evaluar la expresión:\n{e}")
else:
# añadir texto al display
cur = self.display_var.get()
new = cur + label
self.display_var.set(new)


def _load_history(self):
try:
rows = fetch_recent_calculations(limit=30)
self.history_lb.delete(0, tk.END)
for r in rows:
_id, expr, result, created = r
created_str = created.strftime("%Y-%m-%d %H:%M:%S") if isinstance(created, datetime) else str(created)
line = f"[{_id}] {created_str} — {expr} = {result}"
self.history_lb.insert(tk.END, line)
except Exception as e:
# no bloquear la UI si no hay BD disponible; mostrar mensaje y seguir
self.history_lb.delete(0, tk.END)
self.history_lb.insert(tk.END, f"Error cargando historial: {e}")


def _on_history_double_click(self, event):
sel = self.history_lb.curselection()
if not sel:
return
text = self.history_lb.get(sel[0])
# extraer expresión (buscamos "— expr = result")
try:
# formato: "[id] fecha — expr = result"
parts = text.split("—", 1)
if len(parts) >= 2:
right = parts[1].strip()
expr_part = right.rsplit("=", 1)[0].strip()
self.display_var.set(expr_part)
except Exception:
pass


if __name__ == "__main__":
app = CalculatorApp()
app.mainloop()

4) pasos para ejecutar :
crea y ejecuta el script SQL en tu oracle para crear la tabla CALCULATIONS .

Crea un entorno virtual (opcional pero recomendado):
python -m venv venv
# Windows
venv\Scripts\activate
# Linux / macOS
source venv/bin/activate

instala dependencias:
pip install oracledb

si necesitas el cliente Oracle (thick mode) consulta la documentación de oracledb . 
en la mayoría de instalaciones con Oracle XE / servidor remoto y usando thin mode no necesitas instalar cliente adicional .

rellena config.py con tus credenciales y DSN .

ejecuta:
python calculator.py

5) notas y seguridad :

safe_eval usa ast para evitar ejecucion arbitraria de codigo; cubre operaciones aritmeticas basicas. no permite 
funciones externas (como sin, cos) ni nombres. en producción, no almacenes credenciales en config.py en texto plano: usa variables 
de entorno o un gestor seguro. si tu Oracle requiere el oracle client ( thick mode ), puede ser necesario llamar 
a oracledb.init_oracle_client(lib_dir="...") antes de conectar — revisa la documentación de oracledb .
si deseas permitir funciones matematicas (sin, sqrt, etc.), puedo añadir un mapeo controlado de funciones de math ( con seguridad ) .
